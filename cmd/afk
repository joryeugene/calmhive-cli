#!/usr/bin/env node

// AFk Command - Reliable background processing with proper lifecycle management
// Claude That Never Quits

const ProcessManager = require('../lib/process-manager');
const pathManager = require('../lib/path-manager');
const ruleInjector = require('../lib/rule-injector');

class AfkCommand {
  constructor() {
    this.processManager = new ProcessManager();
  }

  async execute() {
    const [,, command, ...args] = process.argv;
    
    // Check for help flag
    if (command === '--help' || command === '-h' || 
        (args.length > 0 && (args[0] === '--help' || args[0] === '-h'))) {
      this.showHelp();
      process.exit(0);
    }
    
    try {
      switch (command) {
        case undefined:
        case 'start':
          await this.startSession(args);
          break;
          
        case 'stop':
          await this.stopSession(args);
          break;
          
        case 'status':
          await this.showStatus(args);
          break;
          
        case 'tail':
          await this.tailLogs(args);
          break;
          
        case 'cleanup':
          await this.cleanup(args);
          break;
          
        case 'resume':
          await this.resumeSession(args);
          break;
          
        case 'stats':
          await this.showStats();
          break;
          
        case 'killorphans':
          await this.killOrphans();
          break;
          
        case 'validate':
          await this.validateSystem(args);
          break;
          
        default:
          // If no subcommand, treat as task description
          await this.startSession([command, ...args]);
          break;
      }
    } catch (error) {
      console.error('‚ùå Error:', error.message);
      process.exit(1);
    }
  }

  async startSession(args) {
    // First parse options to know what to exclude
    const options = this.parseOptions(args);
    
    // Build task by excluding flags AND their values
    const taskArgs = [];
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      
      // Skip ONLY known command flags, not content that happens to start with -
      const knownFlags = ['-i', '-d', '-v', '--iterations', 
                          '--model', '--webhook', '--checkpoint-interval', '--no-prevent-sleep'];
      
      // Only skip if it's an exact known flag OR starts with -- followed by a letter (not ---)
      if (knownFlags.includes(arg) || (arg.startsWith('--') && arg.length > 2 && /^--[a-zA-Z]/.test(arg))) {
        // Skip the value too for flags that take values
        if (['-i', '--iterations', '--model', '--webhook', '--checkpoint-interval'].includes(arg) && i + 1 < args.length) {
          i++; // Skip next arg (the value)
        }
        continue;
      }
      
      taskArgs.push(arg);
    }
    
    const task = taskArgs.join(' ').trim();
    if (!task) {
      console.error('‚ùå Task description required');
      console.log('Usage: calmhive afk "task description" [options]');
      console.log('   or: calmhive afk start "task description" [options]');
      this.showHelp();
      process.exit(1);
    }
    
    // Validate iterations
    if (options.iterations && (options.iterations < 1 || options.iterations > 69)) {
      console.error('‚ùå Iterations must be between 1 and 69');
      process.exit(1);
    }
    
    // Inject CLAUDE.md rules into the task for background processing
    const enhancedTask = ruleInjector.injectRules(task, { 
      commandType: 'afk',
      iterations: options.iterations 
    });
    
    console.log(`üöÄ Starting v${pathManager.getVersion()} AFk session...`);
    
    // Run in foreground for tests, background for normal use
    options.background = !process.env.CALMHIVE_TEST_MODE;
    
    const session = await this.processManager.startAfkSession(enhancedTask, options);
    
    console.log(`\nüìã Session Details:`);
    console.log(`   Session ID: ${session.id}`);
    console.log(`   Task: ${session.task}`);
    console.log(`   Iterations: ${session.iterations_planned}`);
    console.log(`   Sleep Prevention: ${session.iterations_planned > 5 && options.preventSleep !== false ? 'Enabled' : 'Disabled'}`);
    console.log(`\nüìä Monitor: calmhive afk status`);
    console.log(`üìù Logs: calmhive afk tail ${session.id}`);
    console.log(`üõë Stop: calmhive afk stop ${session.id}`);
  }

  async stopSession(args) {
    const sessionId = args[0];
    if (!sessionId) {
      console.error('‚ùå Session ID required');
      console.log('Usage: calmhive afk stop <session-id>');
      process.exit(1);
    }
    
    if (sessionId === '--all' || sessionId === 'all') {
      await this.stopAllSessions();
      return;
    }
    
    await this.processManager.stopSession(sessionId);
  }
  
  async stopAllSessions() {
    console.log('üõë Stopping all running sessions...');
    const sessions = await this.processManager.getStatus();
    const running = sessions.filter(s => s.status === 'running');
    
    if (running.length === 0) {
      console.log('üìä No running sessions to stop');
      return;
    }
    
    let stopped = 0;
    for (const session of running) {
      try {
        await this.processManager.stopSession(session.id);
        stopped++;
      } catch (error) {
        console.error(`‚ùå Failed to stop ${session.id}:`, error.message);
      }
    }
    
    console.log(`‚úÖ Stopped ${stopped} of ${running.length} sessions`);
  }

  async showStatus(args) {
    // Restore any incorrectly marked sessions first
    await this.processManager.restoreRunningSessions();
    
    // Clean up stale sessions
    await this.processManager.cleanupStaleSessions();
    
    // Run comprehensive system integrity validation if --validate or --cleanup flag is provided
    if (args.includes('--validate') || args.includes('--cleanup')) {
      console.log('üîç Running comprehensive system integrity validation...');
      const validation = await this.processManager.validateSystemIntegrity();
      
      if (validation.fixed > 0 || validation.orphansFound > 0) {
        console.log(`üéØ System validation complete:`);
        if (validation.fixed > 0) {
          console.log(`   üîß Fixed ${validation.fixed} database issues`);
        }
        if (validation.orphansFound > 0) {
          console.log(`   üö® Found ${validation.orphansFound} orphaned processes`);
        }
        if (validation.issues.length > 0) {
          console.log(`   üìã Issues resolved: ${validation.issues.slice(0, 3).join(', ')}${validation.issues.length > 3 ? ` and ${validation.issues.length - 3} more` : ''}`);
        }
      } else {
        console.log('‚ú® System integrity validated - no issues found');
      }
    }
    
    // Kill any orphan processes if --cleanup flag is provided
    if (args.includes('--cleanup')) {
      console.log('üîç Scanning for orphan Claude processes...');
      const result = await this.processManager.killOrphanProcesses();
      if (result.killed > 0) {
        console.log(`üßπ Killed ${result.killed} orphan processes: ${result.pids.join(', ')}`);
      }
    }
    
    const detailed = args.includes('-d') || args.includes('--detailed');
    const sessions = await this.processManager.getStatus();
    
    if (sessions.length === 0) {
      console.log('üìä No AFk sessions found');
      console.log('\nüöÄ Start a new session: calmhive afk "your task description"');
      return;
    }
    
    console.log(`üìä v${pathManager.getVersion()} AFk Sessions Summary\n`);
    
    if (detailed) {
      this.showDetailedStatus(sessions);
    } else {
      this.showCompactStatus(sessions);
    }
    
    const stats = await this.processManager.getSessionStats();
    console.log(`\nüìà Total Sessions: ${stats.total}`);
    
    if (stats.running > 0) {
      console.log(`üü¢ Running: ${stats.running}`);
    }
    if (stats.completed > 0) {
      console.log(`‚úÖ Completed: ${stats.completed}`);
    }
    if (stats.error > 0) {
      console.log(`‚ùå Error: ${stats.error}`);
    }
    if (stats.stopped > 0) {
      console.log(`üõë Stopped: ${stats.stopped}`);
    }
    
    if (!detailed) {
      console.log('\nUse "calmhive afk status -d" for detailed view');
    }
  }
  
  showCompactStatus(sessions) {
    const header = 'Session ID'.padEnd(25) + 
                  'Task'.padEnd(35) + 
                  'Status'.padEnd(12) + 
                  'Progress'.padEnd(12) + 
                  'Started';
    
    console.log(header);
    console.log('-'.repeat(header.length));
    
    for (const session of sessions.slice(0, 20)) { // Show latest 20
      const id = session.id; // Show FULL ID for easy copy/paste
      const displayId = id.length > 24 ? id.substring(0, 24) : id;
      const task = session.task.length > 32 ? 
                   session.task.substring(0, 32) + '...' : 
                   session.task;
      const status = this.getStatusIcon(session.status) + session.status;
      const progress = `${session.iterations_completed}/${session.iterations_planned}`;
      const started = new Date(session.started_at).toLocaleString();
      
      console.log(
        displayId.padEnd(25) +
        task.padEnd(35) +
        status.padEnd(12) +
        progress.padEnd(12) +
        started
      );
    }
    
    if (sessions.length > 20) {
      console.log(`\n... and ${sessions.length - 20} more sessions`);
    }
    
    console.log('\nüí° Tip: Copy the full Session ID for tail/stop commands');
  }
  
  showDetailedStatus(sessions) {
    for (const session of sessions.slice(0, 10)) { // Show latest 10 in detail
      console.log(`\n${this.getStatusIcon(session.status)} ${session.id}`);
      console.log(`   Task: ${session.task}`);
      console.log(`   Status: ${session.status}`);
      console.log(`   Progress: ${session.iterations_completed}/${session.iterations_planned}`);
      
      // Check for progress tracking
      if (session.status === 'running' || session.status === 'completed') {
        console.log(`   üìä View detailed progress: calmhive progress ${session.id}`);
      }
      
      if (session.pid) {
        console.log(`   PID: ${session.pid}`);
      }
      
      console.log(`   Started: ${new Date(session.started_at).toLocaleString()}`);
      
      if (session.completed_at) {
        console.log(`   Completed: ${new Date(session.completed_at).toLocaleString()}`);
        const duration = session.completed_at - session.started_at;
        console.log(`   Duration: ${this.formatDuration(duration)}`);
      } else if (session.status === 'running') {
        const elapsed = Date.now() - session.started_at;
        console.log(`   Elapsed: ${this.formatDuration(elapsed)}`);
      }
    }
  }

  async tailLogs(args) {
    const sessionId = args[0];
    if (!sessionId) {
      console.error('‚ùå Session ID required');
      console.log('Usage: calmhive afk tail <session-id>');
      process.exit(1);
    }
    
    await this.processManager.tailLogs(sessionId);
  }

  async cleanup(args) {
    // Parse command line options
    const options = {
      dryRun: args.includes('--dry-run'),
      force: args.includes('--force'),
      verbose: args.includes('--verbose') || args.includes('-v'),
      legacyOnly: args.includes('--legacy-only'),
      dbOnly: args.includes('--db-only')
    };
    
    // Parse days arguments
    const daysArg = args.find(arg => !arg.startsWith('--') && !isNaN(parseInt(arg)));
    const days = parseInt(daysArg) || 7;
    
    // Override retention periods if specified
    if (daysArg) {
      options.completedDays = days;
      options.failedDays = days;
      options.errorDays = days;
      options.stoppedDays = days;
    }
    
    // Use legacy cleanup for basic case
    if (!options.dryRun && !options.force && !options.verbose && 
        !options.legacyOnly && !options.dbOnly && !daysArg) {
      return this.legacyCleanup(days);
    }
    
    // Use comprehensive cleanup engine
    const CleanupEngine = require('../lib/cleanup-engine');
    const engine = new CleanupEngine(options);
    
    // Confirmation prompt unless --force or --dry-run
    if (!options.force && !options.dryRun) {
      console.log(`‚ö†Ô∏è  This will delete sessions older than ${days} days.`);
      console.log('Use --dry-run to preview or --force to skip this prompt.');
      console.log('Press Ctrl+C to cancel or Enter to continue...');
      
      const readline = require('readline').createInterface({
        input: process.stdin,
        output: process.stdout
      });
      
      await new Promise(resolve => {
        readline.question('Continue? [y/N] ', (answer) => {
          readline.close();
          if (answer.toLowerCase() !== 'y' && answer.toLowerCase() !== 'yes') {
            console.log('Cleanup cancelled.');
            process.exit(0);
          }
          resolve();
        });
      });
    }
    
    // Run cleanup
    try {
      const stats = await engine.cleanup(
        this.processManager.db,
        this.processManager
      );
      
      if (stats.deleted === 0 && stats.spaceSaved === 0) {
        console.log('‚ú® No cleanup needed - system is clean!');
      }
      
      return stats;
    } catch (error) {
      console.error('‚ùå Cleanup failed:', error.message);
      throw error;
    }
  }
  
  // Legacy cleanup method for backward compatibility
  async legacyCleanup(days) {
    console.log(`üßπ Cleaning up sessions older than ${days} days...`);
    
    const result = await this.processManager.cleanupCompleted(days);
    
    if (result.sessions === 0 && result.logs === 0) {
      console.log('‚ú® No old sessions to clean up');
    } else {
      console.log(`‚úÖ Cleanup complete:`);
      if (result.sessions > 0) {
        console.log(`   üìä Removed ${result.sessions} old sessions`);
      }
      if (result.logs > 0) {
        console.log(`   üìù Removed ${result.logs} old log files`);
      }
    }
    
    return result;
  }
  
  async showStats() {
    const stats = await this.processManager.getSessionStats();
    
    console.log(`üìà v${pathManager.getVersion()} AFk System Statistics\n`);
    console.log(`Total Sessions: ${stats.total}`);
    
    console.log('\nBy Status:');
    Object.entries(stats.by_status).forEach(([status, count]) => {
      const icon = this.getStatusIcon(status);
      console.log(`  ${icon} ${status}: ${count}`);
    });
    
    console.log('\nBy Type:');
    Object.entries(stats.by_type).forEach(([type, count]) => {
      console.log(`  üìã ${type}: ${count}`);
    });
  }
  
  async killOrphans() {
    console.log('üîç Scanning for orphan Claude processes...');
    const result = await this.processManager.killOrphanProcesses();
    
    if (result.killed > 0) {
      console.log(`\nüßπ Cleanup complete! Killed ${result.killed} orphan processes.`);
      console.log('üí° Tip: Run "calmhive afk status" to see if any sessions need to be marked as stopped.');
    } else {
      console.log('\n‚ú® No orphan processes found - system is clean!');
    }
  }
  
  async validateSystem(args) {
    const fix = args.includes('--fix');
    
    console.log('üîç Running comprehensive AFk system validation...\n');
    
    // Run comprehensive validation
    const validation = await this.processManager.validateSystemIntegrity();
    
    if (validation.fixed > 0 || validation.orphansFound > 0) {
      console.log(`\nüéØ Validation Results:`);
      
      if (validation.fixed > 0) {
        console.log(`   üîß Database Issues Fixed: ${validation.fixed}`);
      }
      
      if (validation.orphansFound > 0) {
        console.log(`   üö® Orphaned Processes Found: ${validation.orphansFound}`);
        
        if (fix) {
          console.log('\nüßπ Cleaning up orphaned processes...');
          const killResult = await this.processManager.killOrphanProcesses();
          if (killResult.killed > 0) {
            console.log(`   ‚úÖ Killed ${killResult.killed} orphan processes: ${killResult.pids.join(', ')}`);
          }
        } else {
          console.log('   üí° Use "calmhive afk validate --fix" to clean up orphan processes');
        }
      }
      
      if (validation.issues.length > 0) {
        console.log(`\nüìã Issues Addressed:`);
        validation.issues.forEach((issue, index) => {
          console.log(`   ${index + 1}. ${issue}`);
        });
      }
    } else {
      console.log('‚ú® System validation complete - no issues found!');
      console.log('üéØ All AFk sessions are properly tracked and synchronized.');
    }
    
    // Show summary stats
    const stats = await this.processManager.getSessionStats();
    console.log(`\nüìä System Summary:`);
    console.log(`   Total Sessions: ${stats.total}`);
    if (stats.running > 0) console.log(`   üü¢ Running: ${stats.running}`);
    if (stats.completed > 0) console.log(`   ‚úÖ Completed: ${stats.completed}`);
    if (stats.error > 0) console.log(`   ‚ùå Error: ${stats.error}`);
    if (stats.stopped > 0) console.log(`   üõë Stopped: ${stats.stopped}`);
  }

  parseOptions(args) {
    const options = {};
    
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      
      if (arg === '--iterations' || arg === '-i') {
        options.iterations = parseInt(args[++i]) || 10;
      } else if (arg === '--model') {
        options.model = args[++i];
      } else if (arg === '--webhook') {
        options.webhook = args[++i];
      } else if (arg === '--checkpoint-interval') {
        options.checkpointInterval = parseInt(args[++i]) || 1800;
      } else if (arg === '--no-prevent-sleep') {
        options.preventSleep = false;
      }
    }
    
    return options;
  }
  
  getStatusIcon(status) {
    const icons = {
      'running': 'üü¢ ',
      'completed': '‚úÖ ',
      'error': '‚ùå ',
      'stopped': 'üõë '
    };
    return icons[status] || '‚ö™ ';
  }
  
  formatDuration(ms) {
    const seconds = Math.floor(ms / 1000) % 60;
    const minutes = Math.floor(ms / 60000) % 60;
    const hours = Math.floor(ms / 3600000);
    
    if (hours > 0) {
      return `${hours}h ${minutes}m ${seconds}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds}s`;
    } else {
      return `${seconds}s`;
    }
  }

  showHelp() {
    console.log(`
üêù Calmhive v${pathManager.getVersion()} AFk - Reliable Background Processing

USAGE:
  calmhive afk "task description" [options]    Start background task
  calmhive afk start "task" [options]          Start background task  
  calmhive afk stop <session-id>               Stop running session
  calmhive afk stop --all                      Stop all running sessions
  calmhive afk resume [session-id]             Resume interrupted session (auto-detects if no ID)
  calmhive afk status                          Show all sessions (compact view)
  calmhive afk status -d                       Show detailed status (full info)
  calmhive afk status --validate               Show status with comprehensive system validation
  calmhive afk status --cleanup                Show status and kill orphan processes (includes validation)
  calmhive afk tail <session-id>               View live logs
  calmhive afk cleanup [days] [options]        Remove old sessions (default: 7 days)
                                       Options: --dry-run, --force, --verbose, --legacy-only, --db-only
  calmhive afk validate                        Run comprehensive system validation
  calmhive afk validate --fix                  Run validation and fix orphan processes
  calmhive afk killorphans                     Kill orphan Claude processes
  calmhive afk stats                           Show system statistics

OPTIONS:
  --iterations N          Number of iterations (default: 10, max: 69)
  --model MODEL           Claude model to use (sonnet, opus)
  --webhook URL           Webhook for progress notifications
  --checkpoint-interval N Checkpoint interval in seconds
  --no-prevent-sleep      Disable automatic sleep prevention (enabled by default for >5 iterations)

EXAMPLES:
  calmhive afk "implement JWT authentication" --iterations 15
  calmhive afk "refactor API endpoints" --model sonnet
  calmhive afk "write unit tests" --iterations 5
  calmhive afk stop abc12345
  calmhive afk cleanup 3                       Delete sessions older than 3 days
  calmhive afk cleanup --dry-run               Preview what would be deleted
  calmhive afk cleanup --force                 Skip confirmation prompt
  calmhive afk cleanup --verbose               Show detailed cleanup progress
  calmhive afk cleanup --legacy-only           Only clean legacy AFk registry files

FEATURES:
  ‚úÖ Reliable process management (no phantom processes)
  ‚úÖ Accurate status tracking with PID verification  
  ‚úÖ Live log viewing and process monitoring
  ‚úÖ Automatic cleanup of completed sessions
  ‚úÖ Resource usage tracking and limits
  ‚òï Automatic sleep prevention for long sessions (>5 iterations)
  üìÖ Scheduler integration - AFk sessions can be scheduled for automation

SCHEDULER INTEGRATION (v14.0.0):
  # Schedule recurring AFk automation
  calmhive schedule create "daily at 6am" "calmhive afk 'security audit' --iterations 8"
  calmhive schedule create "weekly on Friday at 4pm" "calmhive afk 'code review' --iterations 5"
  
  # Monitor scheduled AFk sessions
  calmhive progress <session-id>          View iteration summaries
  calmhive tui                            Monitor all sessions (scheduled and manual)
  
  # Template-driven scheduled automation
  calmhive schedule create "daily at 2am" "$(calmhive template apply performance-optimization)"
    `);
  }

  /**
   * Resume an interrupted session
   */
  async resumeSession(args) {
    const sessionId = args[0];
    
    if (!sessionId) {
      // Find most recent interrupted session
      const sessions = await this.processManager.db.getAllSessions();
      const interrupted = sessions.filter(s => 
        s.status === 'failed' || s.status === 'error' || s.status === 'stopped'
      ).sort((a, b) => b.updated_at - a.updated_at);
      
      if (interrupted.length === 0) {
        console.log('‚ùå No interrupted sessions found to resume');
        return;
      }
      
      const session = interrupted[0];
      console.log(`üîÑ Resuming most recent interrupted session: ${session.id}`);
      console.log(`   Task: ${session.task}`);
      console.log(`   Last status: ${session.status}`);
      
      await this.attemptResume(session);
    } else {
      // Resume specific session
      const session = await this.processManager.db.getSession(sessionId);
      if (!session) {
        console.log(`‚ùå Session ${sessionId} not found`);
        return;
      }
      
      if (session.status === 'running') {
        console.log(`‚ùå Session ${sessionId} is already running`);
        return;
      }
      
      console.log(`üîÑ Resuming session: ${sessionId}`);
      await this.attemptResume(session);
    }
  }

  /**
   * Attempt to resume a session
   */
  async attemptResume(session) {
    try {
      // Validate session is resumable (< 24 hours old)
      const ageHours = (Date.now() - session.updated_at) / (1000 * 60 * 60);
      if (ageHours > 24) {
        console.log(`‚ùå Session is too old to resume (${Math.round(ageHours)} hours)`);
        return;
      }
      
      // Create new session with resume context
      const resumeTask = `[RESUME from iteration ${session.iterations_completed || 0}] ${session.task}`;
      const resumeIterations = Math.max(1, (session.iterations_planned || 5) - (session.iterations_completed || 0));
      
      // Inject CLAUDE.md rules into the resume task
      const enhancedResumeTask = ruleInjector.injectRules(resumeTask, { 
        commandType: 'afk',
        iterations: resumeIterations,
        isResume: true
      });
      
      console.log(`üìù Creating resume session with ${resumeIterations} remaining iterations...`);
      
      // Start new session with resume context
      const metadata = {
        resumed_from: session.id,
        original_task: session.task,
        resume_iteration: (session.iterations_completed || 0) + 1
      };
      
      const newSession = await this.processManager.startAfkSession(
        enhancedResumeTask,
        {
          iterations: resumeIterations,
          background: true,
          metadata
        }
      );
      
      const newSessionId = newSession.id;
      
      console.log(`‚úÖ Resume session started: ${newSessionId}`);
      console.log(`üìä Use 'calmhive afk status' to monitor progress`);
      console.log(`üîç Use 'calmhive afk tail ${newSessionId}' to view logs`);
      
    } catch (error) {
      console.error(`‚ùå Resume failed: ${error.message}`);
      throw error;
    }
  }
}

// Run the command
if (require.main === module) {
  const afk = new AfkCommand();
  afk.execute().catch(error => {
    console.error('üí• Fatal error:', error);
    process.exit(1);
  });
}

module.exports = AfkCommand;