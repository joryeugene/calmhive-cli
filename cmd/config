#!/usr/bin/env node
/**
 * Calmhive Config Command
 * Manages CLAUDE.md configuration files with safety and simplicity
 */

const ConfigManager = require('../lib/config-manager');
const readline = require('readline');

class ConfigCommand {
  constructor() {
    this.configManager = new ConfigManager();
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
  }

  /**
   * Show help information
   */
  showHelp() {
    console.log(`
üêù Calmhive Config - CLAUDE.md Management

Safely manage your CLAUDE.md configuration files with backups and validation.

Usage: calmhive config <command> [options]

Commands:
  show                    Show current configuration status
  diff                    Show differences with template  
  install                 Install/update configuration from template
  backup                  Create manual backup of current config
  restore [filename]      Restore from backup (latest if no filename)
  list-backups           Show available backup files
  commands                Manage command files for external tools like prompthive

Options:
  --dry-run              Preview changes without making them (install only)
  --force                Skip confirmation prompts
  -h, --help             Show this help message

Examples:
  calmhive config show                    # Check current status
  calmhive config diff                    # Preview template changes  
  calmhive config install --dry-run       # See what would be installed
  calmhive config install                 # Install CLAUDE.md template (with backup)
  calmhive config backup                  # Create manual backup
  calmhive config restore                 # Restore latest backup
  calmhive config list-backups           # Show all backups
  calmhive config commands list           # List available command files
  calmhive config commands copy <dest>    # Copy commands to destination directory
  calmhive config commands copy <dest> --pattern expert # Copy only expert commands

Files:
  ~/.claude/CLAUDE.md                     # Your active configuration
  ~/.claude/backups/                      # Timestamped backups
  CLAUDE.md.example                       # CLI-optimized template
  CLAUDE-DESKTOP.md.example               # Desktop-optimized template

Note: All destructive operations create automatic backups for safety.
`);
  }

  /**
   * Show current configuration status
   */
  showStatus() {
    console.log('üîç Configuration Status:\n');
    
    const status = this.configManager.getStatus();
    
    console.log(`üìç Config location: ${status.configPath}`);
    console.log(`üìÅ Exists: ${status.configExists ? '‚úÖ Yes' : '‚ùå No'}`);
    
    if (status.configExists) {
      console.log(`üìÖ Last modified: ${status.lastModified.toLocaleString()}`);
      console.log(`üìè Size: ${Math.round(status.size / 1024)}KB`);
      console.log(`üè∑Ô∏è  Version: ${status.version}`);
    }
    
    console.log(`üîÑ Available backups: ${status.backups.length}`);
    
    // Template availability
    console.log('\nüìã Template:');
    console.log(`   CLAUDE.md: ${status.templateExists ? '‚úÖ Available' : '‚ùå Missing'}`);
  }

  /**
   * Show diff with template
   */
  async showDiff() {
    try {
      const templateName = 'CLAUDE.md';
      console.log(`üîç Comparing with ${templateName}...\n`);
      
      const diff = await this.configManager.getDiff();
      
      if (diff.isNewFile) {
        console.log('üìÑ No existing CLAUDE.md found');
        console.log(`üìã Would create new file from: ${diff.templateName}`);
        console.log(`üìè Template size: ${Math.round(diff.templateSize / 1024)}KB`);
        console.log('\nüí° Run `calmhive config install` to create it');
        return;
      }
      
      if (diff.isIdentical) {
        console.log('‚úÖ Your configuration is identical to the template');
        console.log('üéâ No updates needed!');
        return;
      }
      
      console.log(`üìù Differences found (- current, + template):\n`);
      console.log(diff.diff);
      console.log('\nüí° Run `calmhive config install` to update');
      
    } catch (error) {
      console.error('‚ùå Error showing diff:', error.message);
      process.exit(1);
    }
  }

  /**
   * Install configuration from template
   */
  async installConfig(dryRun = false, force = false) {
    try {
      // Validate template first
      const validation = this.configManager.validateTemplate();
      if (!validation.valid) {
        console.error(`‚ùå Template validation failed: ${validation.error}`);
        process.exit(1);
      }
      
      console.log(`üîç Installing CLAUDE.md template v${validation.version}...`);
      
      if (dryRun) {
        const result = await this.configManager.installConfig(true);
        console.log('\nüìã Dry run - here\'s what would happen:');
        console.log(`   Template: ${result.templateName}`);
        console.log(`   Target: ${result.configPath}`);
        console.log(`   Operation: ${result.isUpdate ? 'Update existing' : 'Create new'}`);
        console.log(`   Size: ${Math.round(result.templateSize / 1024)}KB`);
        if (result.isUpdate) {
          console.log('   Backup: Would be created automatically');
        }
        console.log('\nüí° Remove --dry-run to perform the installation');
        return;
      }
      
      // Show diff if updating existing file
      const status = this.configManager.getStatus();
      if (status.configExists && !force) {
        console.log('\nüìù Current vs Template differences:');
        try {
          const diff = await this.configManager.getDiff();
          if (diff.isIdentical) {
            console.log('‚úÖ No changes needed - files are identical');
            return;
          }
          console.log(diff.diff);
        } catch (error) {
          console.log('‚ö†Ô∏è  Could not show diff, proceeding with install...');
        }
        
        // Ask for confirmation
        if (!await this.askConfirmation('\n‚ùì Continue with installation? (y/N): ')) {
          console.log('‚ùå Installation cancelled');
          return;
        }
      }
      
      // Perform installation
      const result = await this.configManager.installConfig(false);
      
      console.log(`\n‚úÖ Successfully installed ${result.templateName}`);
      console.log(`üìç Location: ${result.configPath}`);
      console.log(`üìè Size: ${Math.round(result.size / 1024)}KB`);
      
      if (result.backupCreated) {
        console.log(`üíæ Previous version backed up to: ${require('path').basename(result.backupCreated.backupPath)}`);
      }
      
      if (result.isUpdate) {
        console.log('\nüéâ Configuration updated successfully!');
      } else {
        console.log('\nüéâ Configuration created successfully!');
      }
      
    } catch (error) {
      console.error('‚ùå Installation failed:', error.message);
      process.exit(1);
    }
  }

  /**
   * Create manual backup
   */
  createBackup() {
    try {
      const backup = this.configManager.createBackup();
      console.log('üíæ Backup created successfully!');
      console.log(`üìç Location: ${backup.backupPath}`);
      console.log(`üìè Size: ${Math.round(backup.size / 1024)}KB`);
    } catch (error) {
      console.error('‚ùå Backup failed:', error.message);
      process.exit(1);
    }
  }

  /**
   * Restore from backup
   */
  async restoreFromBackup(filename, force = false) {
    try {
      const backups = this.configManager.listBackups();
      
      if (backups.length === 0) {
        console.log('‚ùå No backups available to restore');
        return;
      }
      
      if (filename && !backups.find(b => b.filename === filename)) {
        console.log(`‚ùå Backup file not found: ${filename}`);
        console.log('üí° Use `calmhive config list-backups` to see available backups');
        return;
      }
      
      const targetBackup = filename 
        ? backups.find(b => b.filename === filename)
        : backups[0]; // Most recent
      
      console.log(`üîÑ Restoring from: ${targetBackup.filename}`);
      console.log(`üìÖ Created: ${targetBackup.created.toLocaleString()}`);
      console.log(`üìè Size: ${Math.round(targetBackup.size / 1024)}KB`);
      
      if (!force && !await this.askConfirmation('\n‚ùì Continue with restore? (y/N): ')) {
        console.log('‚ùå Restore cancelled');
        return;
      }
      
      const result = this.configManager.restoreFromBackup(filename);
      
      console.log('\n‚úÖ Configuration restored successfully!');
      console.log(`üìç Restored from: ${require('path').basename(result.restoredFrom)}`);
      if (result.currentBackedUpTo) {
        console.log(`üíæ Previous version backed up to: ${require('path').basename(result.currentBackedUpTo)}`);
      }
      
    } catch (error) {
      console.error('‚ùå Restore failed:', error.message);
      process.exit(1);
    }
  }

  /**
   * Handle commands subcommand
   */
  async handleCommandsSubcommand(args) {
    const subcommand = args[1]; // commands <subcommand>
    
    switch (subcommand) {
      case 'list':
        this.listCommandFiles();
        break;
        
      case 'copy':
        const destDir = args[2];
        if (!destDir) {
          console.log('‚ùå Missing destination directory');
          console.log('üí° Usage: calmhive config commands copy <destination>');
          console.log('üí° Example: calmhive config commands copy ./my-commands/');
          console.log('üí° Example: calmhive config commands copy ~/.prompthive/commands/');
          process.exit(1);
        }
        
        const patterns = args.includes('--pattern') ? 
          args.slice(args.indexOf('--pattern') + 1).filter(arg => !arg.startsWith('--')) : [];
        const force = args.includes('--force');
        const dryRun = args.includes('--dry-run');
        
        await this.copyCommandFiles(destDir, { patterns, force, dryRun });
        break;
        
      default:
        console.log('‚ùå Unknown commands subcommand:', subcommand);
        console.log('üí° Available: list, copy');
        process.exit(1);
    }
  }

  /**
   * List available command files
   */
  listCommandFiles() {
    const summary = this.configManager.getCommandFilesSummary();
    
    console.log(`üìÅ Command Files Summary:\n`);
    console.log(`üìä Total files: ${summary.totalFiles}`);
    console.log(`üìè Total size: ${Math.round(summary.totalSize / 1024)}KB\n`);
    
    Object.keys(summary.categories).sort().forEach(category => {
      const files = summary.categories[category];
      console.log(`üìÇ ${category === 'root' ? 'Root Directory' : category}/ (${files.length} files)`);
      
      files.slice(0, 10).forEach(file => {
        const sizeKB = Math.round(file.size / 1024);
        console.log(`   üìÑ ${file.name} (${sizeKB}KB)`);
      });
      
      if (files.length > 10) {
        console.log(`   ... and ${files.length - 10} more files`);
      }
      console.log('');
    });
    
    console.log('üí° Use `calmhive config commands copy <destination>` to copy files');
    console.log('üí° Use `--pattern <text>` to filter files (e.g., --pattern expert)');
  }

  /**
   * Copy command files to destination
   */
  async copyCommandFiles(destDir, options = {}) {
    const { patterns = [], force = false, dryRun = false } = options;
    
    try {
      console.log(`üìã ${dryRun ? 'Previewing' : 'Copying'} command files to: ${destDir}`);
      if (patterns.length > 0) {
        console.log(`üîç Filtering with patterns: ${patterns.join(', ')}`);
      }
      console.log('');
      
      const result = this.configManager.copyCommandFiles(destDir, { patterns, force, dryRun });
      
      if (result.totalFiles === 0) {
        console.log('‚ùå No files match the specified criteria');
        return;
      }
      
      console.log(`üìä Summary:`);
      console.log(`   Total files: ${result.totalFiles}`);
      console.log(`   ${dryRun ? 'Would copy' : 'Copied'}: ${result.copied.length}`);
      console.log(`   Skipped: ${result.skipped.length}`);
      console.log(`   Errors: ${result.errors.length}`);
      console.log('');
      
      // Show copied files
      if (result.copied.length > 0) {
        console.log(`‚úÖ ${dryRun ? 'Would copy' : 'Copied'} files:`);
        result.copied.forEach(item => {
          const action = dryRun ? item.action : (item.action === 'created' ? 'üìù Created' : 'üîÑ Updated');
          console.log(`   ${action}: ${item.file} (${Math.round(item.size / 1024)}KB)`);
        });
        console.log('');
      }
      
      // Show skipped files
      if (result.skipped.length > 0) {
        console.log(`‚è≠Ô∏è  Skipped files (already exist, use --force to overwrite):`);
        result.skipped.forEach(item => {
          console.log(`   üìÑ ${item.file}`);
        });
        console.log('');
      }
      
      // Show errors
      if (result.errors.length > 0) {
        console.log(`‚ùå Errors:`);
        result.errors.forEach(item => {
          console.log(`   ‚ùå ${item.file}: ${item.error}`);
        });
        console.log('');
      }
      
      if (dryRun) {
        console.log('üí° Remove --dry-run to perform the actual copy');
      } else if (result.copied.length > 0) {
        console.log('üéâ Command files copied successfully!');
      }
      
    } catch (error) {
      console.error('‚ùå Copy failed:', error.message);
      process.exit(1);
    }
  }

  /**
   * List available backups
   */
  listBackups() {
    const backups = this.configManager.listBackups();
    
    if (backups.length === 0) {
      console.log('üìÇ No backups found');
      console.log('üí° Create one with: calmhive config backup');
      return;
    }
    
    console.log(`üìÇ Available backups (${backups.length}):\n`);
    
    backups.forEach((backup, index) => {
      const isLatest = index === 0;
      const ageMs = Date.now() - backup.created.getTime();
      const ageDays = Math.floor(ageMs / (1000 * 60 * 60 * 24));
      const ageHours = Math.floor((ageMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      
      let ageStr;
      if (ageDays > 0) {
        ageStr = `${ageDays}d ago`;
      } else if (ageHours > 0) {
        ageStr = `${ageHours}h ago`;
      } else {
        ageStr = 'Recent';
      }
      
      console.log(`   ${isLatest ? 'üìå' : '  '} ${backup.filename}`);
      console.log(`      üìÖ ${backup.created.toLocaleString()} (${ageStr})`);
      console.log(`      üìè ${Math.round(backup.size / 1024)}KB`);
      console.log('');
    });
    
    console.log('üí° Restore with: calmhive config restore [filename]');
  }

  /**
   * Ask for user confirmation
   */
  askConfirmation(question) {
    return new Promise((resolve) => {
      this.rl.question(question, (answer) => {
        resolve(answer.toLowerCase().startsWith('y'));
      });
    });
  }

  /**
   * Clean up readline interface
   */
  cleanup() {
    this.rl.close();
  }

  /**
   * Main execution function
   */
  async execute() {
    // When called directly: ['node', '/path/to/config', 'install', '--force']
    // When called via calmhive: ['node', '/path/to/calmhive', 'config', 'install', '--force']
    const isDirectCall = process.argv[1].includes('/cmd/config');
    const args = isDirectCall ? process.argv.slice(2) : process.argv.slice(3);
    
    // Parse flags
    const dryRun = args.includes('--dry-run');
    const force = args.includes('--force');
    const help = args.includes('--help') || args.includes('-h');
    
    // Get command (first non-flag argument)
    const command = args.find(arg => !arg.startsWith('--') && !arg.startsWith('-'));
    
    try {
      if (help) {
        this.showHelp();
        return;
      }
      
      if (!command) {
        this.showStatus();
        return;
      }
      
      // Handle special case: 'commands' with no subcommand defaults to 'list'
      if (command === 'commands' && args.length === 1) {
        this.listCommandFiles();
        return;
      }
      
      
      switch (command) {
        case 'show':
          this.showStatus();
          break;
          
        case 'diff':
          await this.showDiff();
          break;
          
        case 'install':
          await this.installConfig(dryRun, force);
          break;
          
        case 'backup':
          this.createBackup();
          break;
          
        case 'restore':
          const filename = args.find(arg => !arg.startsWith('--') && arg !== 'restore');
          await this.restoreFromBackup(filename, force);
          break;
          
        case 'list-backups':
          this.listBackups();
          break;
          
        case 'commands':
          await this.handleCommandsSubcommand(args);
          break;
          
        default:
          console.log(`‚ùå Unknown command: ${command}`);
          console.log('üí° Use `calmhive config --help` for available commands');
          process.exit(1);
      }
      
    } catch (error) {
      console.error('‚ùå Command failed:', error.message);
      process.exit(1);
    } finally {
      this.cleanup();
    }
  }

  /**
   * Handle commands subcommand
   */
  async handleCommandsSubcommand(args) {
    const subcommand = args[1]; // commands <subcommand>
    
    switch (subcommand) {
      case 'list':
        this.listCommandFiles();
        break;
        
      case 'copy':
        const destDir = args[2];
        if (!destDir) {
          console.log('‚ùå Missing destination directory');
          console.log('üí° Usage: calmhive config commands copy <destination>');
          console.log('üí° Example: calmhive config commands copy ./my-commands/');
          console.log('üí° Example: calmhive config commands copy ~/.prompthive/commands/');
          process.exit(1);
        }
        
        const patterns = args.includes('--pattern') ? 
          args.slice(args.indexOf('--pattern') + 1).filter(arg => !arg.startsWith('--')) : [];
        const force = args.includes('--force');
        const dryRun = args.includes('--dry-run');
        
        await this.copyCommandFiles(destDir, { patterns, force, dryRun });
        break;
        
      default:
        console.log('‚ùå Unknown commands subcommand:', subcommand);
        console.log('üí° Available: list, copy');
        process.exit(1);
    }
  }

  /**
   * List available command files
   */
  listCommandFiles() {
    const summary = this.configManager.getCommandFilesSummary();
    
    console.log(`üìÅ Command Files Summary:\n`);
    console.log(`üìä Total files: ${summary.totalFiles}`);
    console.log(`üìè Total size: ${Math.round(summary.totalSize / 1024)}KB\n`);
    
    Object.keys(summary.categories).sort().forEach(category => {
      const files = summary.categories[category];
      console.log(`üìÇ ${category === 'root' ? 'Root Directory' : category}/ (${files.length} files)`);
      
      files.slice(0, 10).forEach(file => {
        const sizeKB = Math.round(file.size / 1024);
        console.log(`   üìÑ ${file.name} (${sizeKB}KB)`);
      });
      
      if (files.length > 10) {
        console.log(`   ... and ${files.length - 10} more files`);
      }
      console.log('');
    });
    
    console.log('üí° Use `calmhive config commands copy <destination>` to copy files');
    console.log('üí° Use `--pattern <text>` to filter files (e.g., --pattern expert)');
  }

  /**
   * Copy command files to destination
   */
  async copyCommandFiles(destDir, options = {}) {
    const { patterns = [], force = false, dryRun = false } = options;
    
    try {
      console.log(`üìã ${dryRun ? 'Previewing' : 'Copying'} command files to: ${destDir}`);
      if (patterns.length > 0) {
        console.log(`üîç Filtering with patterns: ${patterns.join(', ')}`);
      }
      console.log('');
      
      const result = this.configManager.copyCommandFiles(destDir, { patterns, force, dryRun });
      
      if (result.totalFiles === 0) {
        console.log('‚ùå No matching files found');
        return;
      }
      
      console.log(`üìã ${dryRun ? 'Would copy' : 'Copied'} ${result.copiedFiles} files`);
      console.log(`üìè Total size: ${Math.round(result.totalSize / 1024)}KB`);
      
      if (result.skippedFiles > 0) {
        console.log(`‚ö†Ô∏è Skipped ${result.skippedFiles} existing files (use --force to overwrite)`);
      }
      
    } catch (error) {
      console.error('‚ùå Copy operation failed:', error.message);
      process.exit(1);
    }
  }
}

// Execute if called directly
if (require.main === module) {
  const configCommand = new ConfigCommand();
  configCommand.execute();
}

module.exports = ConfigCommand;